---
import '../styles/global.css';

const podcastDescription =
  'Podcast nantais indépendant créé par deux devs passionnés : Benjamin Auzanneau et Denis Souron.';

const podcastSubDescription =
  'Si vous êtes une société / une association / une personne, n’hésitez pas à venir nous poser des questions ou si vous avez des idées pour les prochains épisodes.';
const heroImage = '/images/front-end-chronicles-hero.webp';

const podcastLinks = [
  {
    title: 'Apple Podcasts',
    logo: '/images/platforms/apple-podcasts.svg',
    href: 'https://podcasts.apple.com/fr/podcast/front-end-chronicles/id1553915862'
  },
  {
    title: 'Spotify',
    logo: '/images/platforms/spotify.svg',
    href: 'https://open.spotify.com/show/6bULbbUOCaHwFw4bOKsJTL'
  },
  {
    title: 'Deezer',
    logo: '/images/platforms/deezer.png',
    href: 'https://www.deezer.com/fr/show/5626887'
  },
  {
    title: 'Amazon Music',
    logo: '/images/platforms/amazon-music.png',
    href: 'https://music.amazon.fr/podcasts/6455958c-9a7a-4a85-b830-0407eac419c6/front-end-chronicles'
  },
  {
    title: 'podCloud',
    logo: '/images/platforms/podcloud.png',
    href: 'https://podcloud.fr/podcast/front-end-chronicles'
  },
  {
    title: 'YouTube',
    logo: '/images/platforms/youtube.svg',
    href: 'https://www.youtube.com/@FrontEndChronicles'
  },
  {
    title: 'YouTube Music',
    logo: '/images/platforms/youtube-music.svg',
    href: 'https://music.youtube.com/playlist?list=PLT3Txpdfddxal5amXpJIS4DGmDLhLlOyC'
  },
  {
    title: 'Flux RSS',
    logo: '/images/platforms/rss.svg',
    href: 'https://anchor.fm/s/4c31b3c4/podcast/rss'
  }
];

const hosts = [
  {
    name: 'Benjamin Auzanneau',
    role: 'Co-host',
    image: '/images/hosts/benjamin-auzanneau.jpg',
    links: [
      {
        label: 'LinkedIn',
        href: 'https://www.linkedin.com/in/bauzanneau/'
      }
    ]
  },
  {
    name: 'Denis Souron',
    role: 'Co-host',
    image: '/images/hosts/denis-souron.jpg',
    links: [
      {
        label: 'LinkedIn',
        href: 'https://www.linkedin.com/in/denis-souron/'
      }
    ]
  }
];

const appleShowUrl = 'https://podcasts.apple.com/fr/podcast/front-end-chronicles/id1553915862';
const appleEmbedUrl =
  'https://embed.podcasts.apple.com/fr/podcast/front-end-chronicles/id1553915862?itscg=30200&itsct=podcast_box_player';
const rssUrl = 'https://anchor.fm/s/4c31b3c4/podcast/rss';

type Episode = {
  title: string;
  link: string;
  publishedAt: string;
  summary: string;
};

function pickTag(content: string, tag: string): string {
  const regex = new RegExp(`<${tag}[^>]*>([\\s\\S]*?)<\\/${tag}>`, 'i');
  const match = content.match(regex);
  if (!match) return '';

  return match[1]
    .replace(/<!\[CDATA\[([\s\S]*?)\]\]>/gi, '$1')
    .replace(/<[^>]+>/g, '')
    .replace(/&amp;/g, '&')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .trim();
}

function formatDate(value: string): string {
  const parsed = new Date(value);
  if (Number.isNaN(parsed.getTime())) return '';

  return new Intl.DateTimeFormat('fr-FR', {
    dateStyle: 'long'
  }).format(parsed);
}

function truncateText(value: string, maxLength: number): string {
  if (value.length <= maxLength) return value;
  return `${value.slice(0, maxLength).trimEnd()}...`;
}

async function getLatestEpisode(feedUrl: string): Promise<Episode | null> {
  try {
    const response = await fetch(feedUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Astro build)'
      }
    });

    if (!response.ok) {
      return null;
    }

    const xml = await response.text();
    const itemMatch = xml.match(/<item>([\s\S]*?)<\/item>/i);

    if (!itemMatch) {
      return null;
    }

    const item = itemMatch[1];
    const title = pickTag(item, 'title');
    const link = pickTag(item, 'link') || appleShowUrl;
    const publishedAt = formatDate(pickTag(item, 'pubDate'));
    const summary = truncateText(pickTag(item, 'description'), 260);

    return {
      title: title || 'Dernier épisode disponible',
      link,
      publishedAt,
      summary
    };
  } catch {
    return null;
  }
}

const latestEpisode = await getLatestEpisode(rssUrl);
---

<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Front-End Chronicles</title>
    <meta name="description" content={podcastDescription} />
  </head>
  <body>
    <main class="site">
      <header class="hero panel" id="presentation">
        <div class="hero-copy">
          <p class="eyebrow">Podcast Front-End Francophone</p>
          <h1>Front-End Chronicles</h1>
          <p class="lead">{podcastDescription}</p>
          <p class="lead lead-subtle">{podcastSubDescription}</p>
          <div class="hero-actions">
              <a class="btn primary" href={appleShowUrl} target="_blank" rel="noopener noreferrer">
              Écouter sur Apple Podcasts
            </a>
            <a
              class="btn secondary"
              href="https://open.spotify.com/show/6bULbbUOCaHwFw4bOKsJTL"
              target="_blank"
              rel="noopener noreferrer"
            >
              Ouvrir Spotify
            </a>
          </div>
        </div>
        <div class="hero-media">
          <img
            class="hero-media-base"
            src={heroImage}
            alt="Front-End Chronicles podcast cover"
            loading="lazy"
          />
          <img
            class="hero-media-layer hero-media-layer-red"
            src={heroImage}
            alt=""
            aria-hidden="true"
            loading="lazy"
          />
          <img
            class="hero-media-layer hero-media-layer-blue"
            src={heroImage}
            alt=""
            aria-hidden="true"
            loading="lazy"
          />
          <div class="hero-hover-message" aria-hidden="true">
            Oui ? L’effet est incroyable, n’est-ce pas ?
          </div>
        </div>
      </header>

      <section class="panel" id="ecoute-apple">
        <div class="section-head">
          <p class="eyebrow">Lecture intégrée</p>
        </div>

        <div class="player-layout">
          <div class="apple-frame">
            <iframe
              title="Apple Podcasts - Front-End Chronicles"
              src={appleEmbedUrl}
              loading="lazy"
              frameborder="0"
              allow="autoplay *; encrypted-media *; fullscreen *; clipboard-write"
              sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-top-navigation-by-user-activation"
            ></iframe>
          </div>

          <article class="latest-episode">
            <p class="mini-title">Dernier épisode via RSS</p>
            {latestEpisode ? (
              <>
                <h3>{latestEpisode.title}</h3>
                {latestEpisode.publishedAt && <p class="episode-date">{latestEpisode.publishedAt}</p>}
                {latestEpisode.summary && <p class="episode-summary">{latestEpisode.summary}</p>}
                <a
                  class="btn primary"
                  href={latestEpisode.link}
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  Écouter le dernier épisode
                </a>
              </>
            ) : (
              <>
                <h3>Le dernier épisode n’a pas pu être chargé pendant le build.</h3>
                <p class="episode-summary">
                  Le player Apple ci-contre reste disponible et propose les derniers épisodes en direct.
                </p>
                <a class="btn secondary" href={appleShowUrl} target="_blank" rel="noopener noreferrer">
                  Ouvrir la page Apple Podcasts
                </a>
              </>
            )}
          </article>
        </div>
      </section>

      <section class="panel" id="liens-podcast">
        <div class="section-head">
          <p class="eyebrow">Liens</p>
        </div>
        <div class="platform-grid">
          {podcastLinks.map((link) => (
            <a class="platform-card" href={link.href} target="_blank" rel="noopener noreferrer">
              <div class="platform-logo-wrap">
                <img class="platform-logo" src={link.logo} alt={`Logo ${link.title}`} loading="lazy" />
              </div>
              <span>{link.title}</span>
            </a>
          ))}
        </div>
      </section>

      <section class="panel" id="equipe">
        <div class="section-head">
          <p class="eyebrow">Équipe de Front-End Chronicles</p>
        </div>
        <div class="host-grid">
          {hosts.map((host) => (
            <article class="host-card">
              <img src={host.image} alt={host.name} loading="lazy" />
              <div class="host-content">
                <h3>{host.name}</h3>
                <p>{host.role}</p>
                <div class="host-links">
                  {host.links.map((link) => (
                    <a href={link.href} target="_blank" rel="noopener noreferrer">{link.label}</a>
                  ))}
                </div>
              </div>
            </article>
          ))}
        </div>
      </section>
    </main>
    <script is:inline>
      (() => {
        const HOVER_DELAY_MS = 1500;
        const MARGIN_PX = 12;
        const OFFSET_X_PX = 18;
        const OFFSET_Y_PX = 20;
        const OFFSCREEN = '-9999px';

        const media = document.querySelector('.hero-media');
        if (!(media instanceof HTMLElement)) return;

        const message = media.querySelector('.hero-hover-message');
        if (!(message instanceof HTMLElement)) return;

        const state = {
          hovering: false,
          visible: false,
          pointerX: 0,
          pointerY: 0,
          timerId: 0,
          rafId: 0
        };

        const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

        const clearRevealTimer = () => {
          if (state.timerId) {
            window.clearTimeout(state.timerId);
            state.timerId = 0;
          }
        };

        const clearRaf = () => {
          if (state.rafId) {
            window.cancelAnimationFrame(state.rafId);
            state.rafId = 0;
          }
        };

        const hideMessage = () => {
          state.visible = false;
          message.classList.remove('is-visible');
          message.style.left = OFFSCREEN;
          message.style.top = OFFSCREEN;
        };

        const updatePosition = () => {
          state.rafId = 0;
          if (!state.visible) return;

          const rect = media.getBoundingClientRect();
          const rawX = state.pointerX - rect.left + OFFSET_X_PX;
          const rawY = state.pointerY - rect.top + OFFSET_Y_PX;
          const maxX = Math.max(MARGIN_PX, rect.width - message.offsetWidth - MARGIN_PX);
          const maxY = Math.max(MARGIN_PX, rect.height - message.offsetHeight - MARGIN_PX);

          const x = clamp(rawX, MARGIN_PX, maxX);
          const y = clamp(rawY, MARGIN_PX, maxY);

          message.style.left = `${x}px`;
          message.style.top = `${y}px`;
        };

        const requestPositionUpdate = () => {
          if (state.rafId) return;
          state.rafId = window.requestAnimationFrame(updatePosition);
        };

        const setPointer = (event) => {
          state.pointerX = event.clientX;
          state.pointerY = event.clientY;
        };

        const revealMessage = () => {
          if (!state.hovering) return;
          state.visible = true;
          message.classList.add('is-visible');
          requestPositionUpdate();
        };

        const onEnter = (event) => {
          state.hovering = true;
          setPointer(event);
          clearRevealTimer();
          hideMessage();
          state.timerId = window.setTimeout(revealMessage, HOVER_DELAY_MS);
        };

        const onMove = (event) => {
          if (!state.hovering) return;
          setPointer(event);
          if (state.visible) requestPositionUpdate();
        };

        const onLeave = () => {
          state.hovering = false;
          clearRevealTimer();
          clearRaf();
          hideMessage();
        };

        const controller = new AbortController();
        const listenerOptions = { signal: controller.signal };

        media.addEventListener('pointerenter', onEnter, listenerOptions);
        media.addEventListener('pointermove', onMove, listenerOptions);
        media.addEventListener('pointerleave', onLeave, listenerOptions);
        media.addEventListener('pointercancel', onLeave, listenerOptions);
        window.addEventListener(
          'resize',
          () => {
            if (state.visible) requestPositionUpdate();
          },
          listenerOptions
        );
        document.addEventListener(
          'visibilitychange',
          () => {
            if (document.hidden) onLeave();
          },
          listenerOptions
        );
        window.addEventListener(
          'pagehide',
          () => {
            controller.abort();
            clearRevealTimer();
            clearRaf();
          },
          { once: true }
        );
      })();
    </script>
  </body>
</html>
